= Introduction =

This page will provide a quick overview in the steps needed in creating additional JSF Flex Components / Renderers.

= Details =

===Components===
 # Create a class with the following naming convention : {{{AbstractMXMLUI<NameOfComponent>}}}
 # Add the {{{JavaDocs}}} that are needed in 
     * creating the concrete component and the tagClass.
     * inserting the component and the tagClass information to the faces-config.xml and jsf-flex.tld.
     * defining the default renderer of the component.
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     * @JSFComponent
     *   name     = "jf:mxmlAccordion"
     *   class    = "com.googlecode.jsfFlex.component.ext.MXMLUIAccordion"
     *   type     = "com.googlecode.jsfFlex.MXMLUIAccordion"
     *   tagClass = "com.googlecode.jsfFlex.taglib.ext.MXMLUIAccordionTag"
     *   family   = "javax.faces.MXMLInput"
     *   defaultRendererType= "com.googlecode.jsfFlex.MXMLAccordion"
   }}}
 # Add the {{{JavaDocs}}} needed in creating properties for the component and the to be created tagClass. *Note that the convention is to include all the properties of the to be created concrete component and any of the concrete components that it extends within the {{{JavaDoc}}}. This will ensure that the properties will be pushed to the attributes Map and decrease the size of the component class with lessening of it's getter and setter methods.*
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     * @JSFJspProperties
     * 		properties =		
     *   			@JSFJspProperty
     * 				 name		= "headerRenderer"
     *   			 returnType	= "java.lang.String"
     *   			 longDesc	= "A factory used to create the navigation buttons for each child."
     *   			,
     *   			
     *   			@JSFJspProperty
     *   			 name		= "selectedFillColors"
     *   			 returnType	= "java.lang.String"
     *   			 longDesc	= "The two colors used to tint the background of the component when inits selected state."
     *   				, 
   }}}
 # Add the interfaces of attributes needed for NON-concrete components {i.e. {{{_MXMLUIContainerAttributes}}} } and any additional attributes.
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     implements _MXMLUIContainerAttributes, _MXMLUIBaseAttributes, _MXMLUITextAttribute, 
		_MXMLUIBackgroundAlphaAttribute,
   }}}
 # Choose the abstract component to extend for the base functionality. If one desires to create a new abstract component, please note that one must implement {{{_MXMLContract}}}.
    Here is an example from AbstractMXMLUIAccordion.java
    {{{
      public abstract class AbstractMXMLUIAccordion 
						extends MXMLUISelectedIndexBase
    }}}

===Renderers===
 # Create a class with the following naming convention for renderKit14 and renderKit15 maven projects : {{{MXML<NameOfRenderer>Rederer}}}
 # Include the {{{JavaDocs}}} to insert the renderer information to faces-config.xml.
    Here is an example from {{{MXMLAccordionRenderer}}}
    {{{
      * @JSFRenderer 
      *   renderKitId = "MTML_BASIC" 
      *   family      = "javax.faces.MXMLInput"
      *   type        = "com.googlecode.jsfFlex.MXMLAccordion"
    }}}
 # Add 
   # the {{{JavaDoc}}} and annotation for properties of the subclass of UIComponent to identify whether to fetch the information from the attributes Map or by method invocation. This has direct relationship with how the properties have been added within JSF Flex Components. For example if the properties have been 
     * noted as {{{JavaDoc}}} within the abstract class, it means it should be fetched from the attribute Map.
     * noted as interfaces for the abstract class, it means it should be fetched by method invocation.
   One thing to note for JSF Flex Renderers is that ONLY the properties that belong to that subclass UIComponent should be inserted within that class and if the concrete component's properties are shared between components {i.e. other components extend from it} one should create the {{{MXML<ComponentName>TemplateRenderer}}} and have those classes extend from this Template class.
   # the {{{JavaDoc}}} and annotation to define the component's post-back information, if the values of the component needs to be retrieved from the client side and mapped to the managed bean. These information will be used to generate {{{componentValueMapper.xml}}} JSF Flex Plug-in {Optional}
  How these fields should be set differ for renderKit14 and renderKit15 projects. For
   * renderKit14 project, they should be set as {{{JavaDocs}}} as shown below for {{{MXMLAccordionRenderer}}}
     {{{
      * @JsfFlexAttributes
      *  headerRenderer=false
      *  historyManagementEnabled=false
      *  resizeToContent=false
      * ...
      * 
      * @JsfFlexComponentValueClassInfo
      *  classPackage=mx.containers
      *  className=Accordion
      *  
      * @JsfFlexComponentNodeAttribute
      *  htmlType=INPUT
      *  typeAttributeValue=HIDDEN
      *  valueAttributeValue=selectedIndex
      *  valueDynamic=true
      *  valueNested=false
      *  nameAttributeValue=id
      *  nameDynamic=true
      *  nameAppend=_selectedIndex
     }}}
   * renderKit15 project, they should be set by annotation as shown below for {{{MXMLAccordion}}}
     {{{
      @JsfFlexAttributeProperties(
	componentName="Accordion",
	mxmlComponentPackage="mx.containers",
        mxmlComponentName="Accordion",
	componentNodeAttributes={
	    @JsfFlexComponentNodeAttribute(htmlType="INPUT",
			typeAttributeValue="HIDDEN",
			valueAttributeValue="selectedIndex",
			isValueDynamic=true,
			isValueNested=false,
		        valueNestedValues={},
			nameAttributeValue="id",
			isNameDynamic=true,
			nameAppend="_selectedIndex")
	},
        
	jsfFlexAttributes={
		@JsfFlexAttribute(attribute="headerRenderer", byMethod=false),
		@JsfFlexAttribute(attribute="historyManagementEnabled", byMethod=false),
		@JsfFlexAttribute(attribute="resizeToContent", byMethod=false),
     }}}
 # If one needs the renderer created without other specific needs, all one needs to do is add {{{mapFields}}} and {{{createPreMxmlTask}}} method calls within {{{encodeBegin}}} method. Depending on which component1<4 | 5> project, the parameters will differ. For
   * renderKit14, here is an example of {{{MXMLAccordionRenderer}}}
     {{{
       private static final String MXML_ACCORDION_REPLACE_MAPPING;
       private static final String MXML_COMPONENT_NAME = "Accordion";
       
       static{
           //TODO : find a better method to implement the below tasks
	   String packageName = MXMLAccordionRenderer.class.getPackage().getName();
	   packageName = packageName.replace('.', '/');
	   MXML_ACCORDION_REPLACE_MAPPING = packageName + "/replaceMapping/MXMLAccordionRendererReplaceMapping.xml";
       }
       
       public void encodeBegin(FacesContext context, UIComponent componentObj) throws IOException {
           super.encodeBegin(context, componentObj);
	   
	   _MXMLContract componentMXML = (_MXMLContract) componentObj;
	   
	   MXMLResponseWriterImpl writer = (MXMLResponseWriterImpl) context.getResponseWriter();
	   writer.mapFields(MXMLAccordionRenderer.class, componentObj, MXML_ACCORDION_REPLACE_MAPPING);
	   writer.createPreMxml(writer, componentMXML, MXML_COMPONENT_NAME, null);
	   
	}
     }}}
   * renderKit15, here is an example of {{{MXMLAccordionRenderer}}}
     {{{
       @Override
	public void encodeBegin(FacesContext context, UIComponent componentObj) throws IOException {
	   super.encodeBegin(context, componentObj);
	   
	   _MXMLContract componentMXML = (_MXMLContract) componentObj;
	   
	   MXMLResponseWriterImpl writer = (MXMLResponseWriterImpl) context.getResponseWriter();
	   writer.mapFields(MXMLAccordionRenderer.class, componentObj, null);
	   writer.createPreMxml(writer, componentMXML, MXMLAccordionRenderer.class.getAnnotation(JsfFlexAttributeProperties.class).componentName(), 
				null);
	   
	}
	
     }}}


All these input are simply to assist new users in creating new components within the project and as always the best method in understanding the process is simply to dig through code and get your hands dirty in seeing how the current components/renderers are created. The framework itself follows a specific pattern, so the creation of new components/renderers is rather easy once you get the hang of it.