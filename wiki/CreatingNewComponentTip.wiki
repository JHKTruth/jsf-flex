= Introduction =

This page will provide a quick overview in the steps needed in creating additional JSF Flex components.

= Details =

==JSF Flex {JSF side}==

===Components===
 # Create a class with the following naming convention : {{{AbstractMXMLUI<NameOfComponent>}}}
 # Add the javaDocs that are needed in 
     * creating the concrete component and the tagClass.
     * inserting the component and the tagClass information to the faces-config.xml and jsf-flex.tld.
     * defining the default renderer of the component.
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     * @JSFComponent
     *   name     = "jf:mxmlAccordion"
     *   class    = "com.googlecode.jsfFlex.component.ext.MXMLUIAccordion"
     *   type     = "com.googlecode.jsfFlex.MXMLUIAccordion"
     *   tagClass = "com.googlecode.jsfFlex.taglib.ext.MXMLUIAccordionTag"
     *   family   = "javax.faces.MXMLInput"
     *   tagSuperclass = "org.apache.myfaces.shared_impl.taglib.UIComponentTagBase"
     *   defaultRendererType= "com.googlecode.jsfFlex.MXMLInput"
   }}}
 # Add the javaDocs needed in creating properties for the component and the to be created tagClass. *Note that the convention is to include all the properties of the to be created concrete component and any of the concrete components that it extends within the javaDoc. This will ensure that the properties will be pushed to the attributes Map and decrease the size of the component class with lessening of it's getter and setter methods.*
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     * @JSFJspProperties
     * 		properties	=		
     *   				@JSFJspProperty
     * 					 name		= "headerRenderer"
     *   				 returnType	= "java.lang.String"
     *   				 longDesc	= "A factory used to create the navigation buttons for each child."
     *   				,
     *   				
     *   				@JSFJspProperty
     *   				 name		= "selectedFillColors"
     *   				 returnType	= "java.lang.String"
     *   				 longDesc	= "The two colors used to tint the background of the component when inits selected state."
     *   				, 
   }}}
 # Add the interfaces of attributes needed for NON-concrete components {i.e. {{{_MXMLUIContainerAttributes}}} } and any additional attributes.
   Here is an example from AbstractMXMLUIAccordion.java
   {{{
     implements _MXMLUIContainerAttributes, _MXMLUIBaseAttributes, _MXMLUITextAttribute, 
		_MXMLUIBackgroundAlphaAttribute,
   }}}
 # Choose the abstract component to extend for the base functionality. If one desires to create a new abstract component, please note that one must implement {{{_MXMLContract}}} to integrate with the JSF Flex Framework.
    Here is an example from AbstractMXMLUIAccordion.java
    {{{
      public abstract class AbstractMXMLUIAccordion 
						extends MXMLUISelectedIndexBase
    }}}
 # Implement the {{{getMXMLComponentRenderer}}} method to define which JSF Flex Framework component maps to the current JSF Flex component.
    Here is an example from AbstractMXMLUIAccordion.java
    {{{
        private static final String MXML_COMPONENT_RENDERER = "com.googlecode.jsfFlex.MXMLAccordion";
	
	public String getMXMLComponentRenderer() {
		return MXML_COMPONENT_RENDERER;
	}
    }}}

===Renderers===
 # Create a class with the following naming convention : {{{MXML<NameOfRenderer>Rederer}}}
 # Include the javaDocs to insert the renderer information to faces-config.xml.
    Here is an example from MXMLInputRenderer
    {{{
      * @JSFRenderer 
      *   renderKitId = "HTML_BASIC" 
      *   family      = "javax.faces.MXMLInput"
      *   type        = "com.googlecode.jsfFlex.MXMLInput"
    }}}
 # Have the renderer extend {{{MXMLRendererBase}}}
    Here is an example from MXMLInputRenderer
    {{{
      public class MXMLInputRenderer extends MXMLRendererBase
    }}}


==JSF Flex Framework==

===Component===
 # Create a class with the following naming convention : {{{MXML<NameOfJSFFlexFrameworkComponent>}}}
 # Create these classes for component14 and component15 maven projects.
 # Add the properties of the component and identify whether to fetch the information from the attributes Map or by method invocation. This has direct relationship with how the properties have been added within JSF Flex Components. For example if the properties have been 
   * noted as javaDoc within the abstract class, it means it should be fetched from the attribute Map.
   * noted as interfaces for the abstract class, it means it should be fetched by method invocation.
  How these fields should be set differ for component14 and component15 projects. For
   * component14 project, they should be set as javaDocs as shown below for {{{MXMLAccordion}}}
     {{{
      * @JsfFlexAttributes
      * 	headerRenderer=false
      * 	historyManagementEnabled=false
      * 	resizeToContent=false
      * ...
      * @JsfFlexRenderKitAttribute
      *  componentFamily=javax.faces.MXMLInput
      *  rendererName=com.googlecode.jsfFlex.MXMLAccordion
      *  rendererClass=com.googlecode.jsfFlex.framework.component.ext.MXMLAccordion
     }}}
   * component15 project, they should be set by annotation as shown below for {{{MXMLAccordion}}}
     {{{
      @JsfFlexAttributeProperties(
	componentName="Accordion",
	componentFamily="javax.faces.MXMLInput",
	rendererName="com.googlecode.jsfFlex.MXMLAccordion",
	rendererClass="com.googlecode.jsfFlex.framework.component.ext.MXMLAccordion",
        
	jsfFlexAttributes={
		@JsfFlexAttribute(attribute="headerRenderer", byMethod=false),
		@JsfFlexAttribute(attribute="historyManagementEnabled", byMethod=false),
		@JsfFlexAttribute(attribute="resizeToContent", byMethod=false),
     }}}
   One thing to note for JSF Flex Framework components is that ONLY the properties that belong to that component should be inserted within that class and if the concrete component's properties are shared between components {i.e. other components extend from it} one should create the {{{MXML<ComponentName>Template}}} and have those classes extend from this Template class. Another thing to note is the other javaDoc and annotation that are included for each Java file, so to insert its information into mxmlRenderKit.xml file.
 # If one needs the component created without other specific needs, all one needs to do is add {{{mapFields}}} and {{{addCreatePreMxmlTask}}} method calls within {{{buildComponentBegin}}} and {{{buildComponentInterlude}}} methods respectively. Depending on which component1<4 | 5> project, the parameters will differ. For
   * component14, here is an example of {{{MXMLAccordion}}}
     {{{
       private static final String MXML_ACCORDION_REPLACE_MAPPING;
       private static final String MXML_COMPONENT_NAME = "Accordion";
       
       static{
           //TODO : find a better method to implement the below tasks
	   String packageName = MXMLAccordion.class.getPackage().getName();
	   packageName = packageName.replace('.', '/');
	   MXML_ACCORDION_REPLACE_MAPPING = packageName + "/replaceMapping/MXMLAccordionReplaceMapping.xml";
       }
       
       public void buildComponentBegin(Object componentObj) throws ComponentBuildException{
		super.buildComponentBegin(componentObj);
		
		mapFields(MXMLAccordion.class, componentObj, MXML_ACCORDION_REPLACE_MAPPING);
		
	}
	
	public void buildComponentInterlude(Object componentObj) throws ComponentBuildException {
		super.buildComponentInterlude(componentObj);
		
		_MXMLContract componentMXML = (_MXMLContract) componentObj;
		addCreatePreMxmlTask(componentMXML, MXML_COMPONENT_NAME, null);
		
	}
     }}}
   * component15, here is an example of {{{MXMLAccordion}}}
     {{{
       public void buildComponentBegin(Object componentObj) throws ComponentBuildException{
		super.buildComponentBegin(componentObj);
		
		mapFields(MXMLAccordion.class, componentObj, null);
		
	}
	
	public void buildComponentInterlude(Object componentObj) throws ComponentBuildException {
		super.buildComponentInterlude(componentObj);
		
		_MXMLContract componentMXML = (_MXMLContract) componentObj;
		addCreatePreMxmlTask(componentMXML, MXMLAccordion.class.getAnnotation(JsfFlexAttributeProperties.class).componentName(), 
								null);
		
	}
     }}}
 # One final thing to remember, if the data needs to be passed back to the server side and mapped to the managed bean, is to add an entry within jsf-flex-framework/core's componentValueMapper.xml.


All these input are simply to assist new users in creating new components within the project and as always the best method in understanding the process is simply to dig through code and get your hands dirty in seeing how the current components are created. The framework itself follows a specific pattern, so the creation of new components is rather easy once you get the hang of it.